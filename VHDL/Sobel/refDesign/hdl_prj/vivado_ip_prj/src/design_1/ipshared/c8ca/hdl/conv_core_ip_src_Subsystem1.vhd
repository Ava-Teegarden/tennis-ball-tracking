-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj\hdlsrc\sobelFilter2024a\conv_core_ip_src_Subsystem1.vhd
-- Created: 2025-04-19 00:07:28
-- 
-- Generated by MATLAB 24.2, HDL Coder 24.2, and Simulink 24.2
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: conv_core_ip_src_Subsystem1
-- Source Path: sobelFilter2024a/conv_core/color_correct_core/Subsystem1
-- Hierarchy Level: 2
-- Model version: 9.17
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;

ENTITY conv_core_ip_src_Subsystem1 IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        channel_in                        :   IN    std_logic_vector(31 DOWNTO 0);  -- uint32
        Enable                            :   IN    std_logic;
        Video_out                         :   OUT   std_logic_vector(31 DOWNTO 0)  -- uint32
        );
END conv_core_ip_src_Subsystem1;


ARCHITECTURE rtl OF conv_core_ip_src_Subsystem1 IS

  -- Signals
  SIGNAL enb_gated                        : std_logic;
  SIGNAL alphavalid                       : std_logic;
  SIGNAL Check_For_White_out1             : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL channel_in_unsigned              : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Bit_Slice2_out1                  : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Bit_Slice1_out1                  : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Max1_stage1_1_val                : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Bit_Slice_out1                   : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Max1_stage2_val                  : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Max2_stage1_1_val                : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Max2_stage2_val                  : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Subtract_sub_cast                : signed(8 DOWNTO 0);  -- sfix9
  SIGNAL Subtract_sub_cast_1              : signed(8 DOWNTO 0);  -- sfix9
  SIGNAL Subtract_out1                    : signed(8 DOWNTO 0);  -- sfix9
  SIGNAL GreaterThanOrEqual_cast          : signed(8 DOWNTO 0);  -- sfix9
  SIGNAL GreaterThanOrEqual_out1          : std_logic;
  SIGNAL Brightness_Check_out1            : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL GreaterThanOrEqual1_out1         : std_logic;
  SIGNAL AND_out1                         : std_logic;
  SIGNAL switch_compare_1                 : std_logic;
  SIGNAL Shift_Arithmetic4_out1           : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Shift_Arithmetic4_out1_is_not0   : std_logic;
  SIGNAL Shift_Arithmetic1_out1           : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Shift_Arithmetic1_out1_is_not0   : std_logic;
  SIGNAL Shift_Arithmetic2_out1           : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL Shift_Arithmetic2_out1_is_not0   : std_logic;
  SIGNAL B_out1                           : unsigned(7 DOWNTO 0);  -- uint8
  SIGNAL B_out1_is_not0                   : std_logic;
  SIGNAL OR_out1                          : std_logic;
  SIGNAL OR_out1_dtc                      : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Switch_out1                      : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Switch_out1_bypass               : unsigned(31 DOWNTO 0);  -- uint32
  SIGNAL Switch_out1_last_value           : unsigned(31 DOWNTO 0);  -- uint32

BEGIN

  alphavalid <= Enable;

  enb_gated <= alphavalid AND enb;

  Check_For_White_out1 <= to_unsigned(16#4B#, 8);

  channel_in_unsigned <= unsigned(channel_in);

  Bit_Slice2_out1 <= channel_in_unsigned(23 DOWNTO 16);

  Bit_Slice1_out1 <= channel_in_unsigned(15 DOWNTO 8);

  ---- Tree max implementation ----
  
  Max1_stage1_1_val <= Bit_Slice2_out1 WHEN Bit_Slice2_out1 >= Bit_Slice1_out1 ELSE
      Bit_Slice1_out1;

  Bit_Slice_out1 <= channel_in_unsigned(7 DOWNTO 0);

  
  Max1_stage2_val <= Max1_stage1_1_val WHEN Max1_stage1_1_val >= Bit_Slice_out1 ELSE
      Bit_Slice_out1;

  ---- Tree min implementation ----
  
  Max2_stage1_1_val <= Bit_Slice2_out1 WHEN Bit_Slice2_out1 <= Bit_Slice1_out1 ELSE
      Bit_Slice1_out1;

  
  Max2_stage2_val <= Max2_stage1_1_val WHEN Max2_stage1_1_val <= Bit_Slice_out1 ELSE
      Bit_Slice_out1;

  Subtract_sub_cast <= signed(resize(Max1_stage2_val, 9));
  Subtract_sub_cast_1 <= signed(resize(Max2_stage2_val, 9));
  Subtract_out1 <= Subtract_sub_cast - Subtract_sub_cast_1;

  GreaterThanOrEqual_cast <= signed(resize(Check_For_White_out1, 9));
  
  GreaterThanOrEqual_out1 <= '1' WHEN GreaterThanOrEqual_cast >= Subtract_out1 ELSE
      '0';

  Brightness_Check_out1 <= to_unsigned(16#32#, 8);

  
  GreaterThanOrEqual1_out1 <= '1' WHEN Max2_stage2_val >= Brightness_Check_out1 ELSE
      '0';

  AND_out1 <= GreaterThanOrEqual_out1 AND GreaterThanOrEqual1_out1;

  
  switch_compare_1 <= '1' WHEN AND_out1 > '0' ELSE
      '0';

  Shift_Arithmetic4_out1 <= to_unsigned(16#00#, 8);

  
  Shift_Arithmetic4_out1_is_not0 <= '1' WHEN Shift_Arithmetic4_out1 /= to_unsigned(16#00#, 8) ELSE
      '0';

  Shift_Arithmetic1_out1 <= to_unsigned(16#00#, 8);

  
  Shift_Arithmetic1_out1_is_not0 <= '1' WHEN Shift_Arithmetic1_out1 /= to_unsigned(16#00#, 8) ELSE
      '0';

  Shift_Arithmetic2_out1 <= to_unsigned(16#00#, 8);

  
  Shift_Arithmetic2_out1_is_not0 <= '1' WHEN Shift_Arithmetic2_out1 /= to_unsigned(16#00#, 8) ELSE
      '0';

  B_out1 <= to_unsigned(16#19#, 8);

  
  B_out1_is_not0 <= '1' WHEN B_out1 /= to_unsigned(16#00#, 8) ELSE
      '0';

  OR_out1 <= B_out1_is_not0 OR (Shift_Arithmetic2_out1_is_not0 OR (Shift_Arithmetic4_out1_is_not0 OR Shift_Arithmetic1_out1_is_not0));

  OR_out1_dtc <= '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & '0' & OR_out1;

  
  Switch_out1 <= channel_in_unsigned WHEN switch_compare_1 = '0' ELSE
      OR_out1_dtc;

  Video_out_bypass_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      Switch_out1_last_value <= to_unsigned(0, 32);
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb_gated = '1' THEN
        Switch_out1_last_value <= Switch_out1_bypass;
      END IF;
    END IF;
  END PROCESS Video_out_bypass_process;


  
  Switch_out1_bypass <= Switch_out1_last_value WHEN alphavalid = '0' ELSE
      Switch_out1;

  Video_out <= std_logic_vector(Switch_out1_bypass);

END rtl;

